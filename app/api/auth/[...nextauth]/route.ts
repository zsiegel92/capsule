import NextAuth, { type NextAuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import prisma from "@/lib/prisma";
import jwt from 'jsonwebtoken';
import { compare } from 'bcrypt';
import { getServerSession as defaultGetServerSession } from 'next-auth/next';

import type {
    JWT,
    JWTDecodeParams,
    JWTEncodeParams,
    JWTOptions,
} from 'next-auth/jwt';

export const authOptions: NextAuthOptions = {
    providers: [
        CredentialsProvider({
            credentials: {
                email: { label: 'Email', type: 'email' },
                password: { label: 'Password', type: 'password' },
            },
            // @ts-ignore
            async authorize(credentials) {
                const { email, password } = credentials ?? {};
                if (!email || !password) {
                    throw new Error('Missing username or password');
                }
                const user = await prisma.user.findUnique({
                    where: {
                        email,
                    },
                });
                // if user doesn't exist or password doesn't match
                if (!user || !(await compare(password, user.password))) {
                    throw new Error('Invalid username or password');
                }
                return user;
            },
        }),
    ],
    session: { strategy: 'jwt' },
    jwt: {
        maxAge: 60 * 60 * 24 * 30,
        async encode({ secret, token }) {
            // console.log('ENCODING');
            // console.log(token);
            // token has shape {email: string, name: string | undefined, image: undefined}
            // { user: token }
            let signed = jwt.sign(token, secret, {
                algorithm: 'HS256',
            });
            // console.log('ENCODED');
            // console.log(signed);
            return signed;
        },
        async decode({ secret, token }) {
            // console.log('DECODING');
            // console.log(token);
            let decoded = jwt.verify(token, secret, {
                algorithms: ['HS256'],
            });
            // console.log('DECODED');
            // console.log(decoded);
            return decoded;
        },
    },
    callbacks: {
        async jwt({
            token,
            // account,
            // profile,
        }) {
            // Persist the OAuth access_token and or the user id to the token right after signin
            // console.log('IN JWT CALLBACK');
            // console.log('TOKEN');
            // console.log(token);
            return token;
        },
        async session({
            session,
            token,
            // user,
        }) {
            // Send properties to the client, like an access_token and user id from a provider.
            // session.accessToken = token.accessToken
            // session.user.id = token.id
            // session.iat = token.iat;
            // console.log('IN SESSION CALLBACK');
            // console.log('SESSION');
            // console.log(session);
            // console.log('TOKEN');
            // console.log(token);
            return session;
        },
    },
};

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };

export const getServerSession = async ()=> await defaultGetServerSession(authOptions) 
// export default NextAuth({ ...authOptions });
// Generated by copilot, doesn't work. 'JWEInvalid: Invalid Compact JWE\n' +
// jwt: {
//   async encode({ secret, token, maxAge }) {
//       const encodedToken = await jwt.sign(token, secret, {
//           algorithm: 'HS512',
//           expiresIn: maxAge,
//       });
//       return encodedToken;
//   },
//   async decode({ secret, token }) {
//       const decodedToken = await jwt.verify(token, secret);
//       return decodedToken;
//   },
// },